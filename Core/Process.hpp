#ifndef TESTPROJECT_PROCESS_HPP
#define TESTPROJECT_PROCESS_HPP

#include <csignal>
#include <vector>
#include <iostream>
#include <optional>

#include "../Filesystem/FileManager.hpp"
#include "./MemoryBlock.hpp"

class Process
{
    static constexpr auto HEAP = "[heap]";
    static constexpr auto STACK = "[stack]";

    pid_t _pid;
    std::vector<MemoryBlock> _process_addrs;

public:
    Process(pid_t pid, std::vector<MemoryBlock>& process_addrs) :
        _pid(pid), _process_addrs(std::move(process_addrs))
    {
    }

    std::vector<char> readProcessMemBlock(uint64_t offset, uint64_t size) const
    {
        try
        {
            FileManager mem_file;
            std::vector<char> buffer(size);

            std::string mem_file_name = "/proc/" + std::to_string(_pid) + "/mem";

            mem_file.openFile(mem_file_name.c_str(), O_RDONLY);
            mem_file.seek(offset);
            mem_file.readIntoBuffer(buffer, size, offset);

            return buffer;
        }
        catch(std::exception& e)
        {
            throw std::runtime_error("Error in Read Process " + std::to_string(_pid) + " Mem: " + e.what());
        }
    }

    void terminateProcess() const
    {
        int terminate = kill(_pid, SIGTERM);

        std::cout << "Process Id: " << _pid << " Terminated Successfully" << std::endl;

        if(terminate != 0)
        {
            throw std::runtime_error("Failed Terminate Process");
        }
    }

    const std::vector<MemoryBlock>& getMemoryBlocks() const
    {
        return _process_addrs;
    }

    static std::vector<MemoryBlock> getProcessMemoryAddresses(pid_t pid)
    {
        std::vector<MemoryBlock> process_addresses;
        FileManager maps_file("/proc/" + std::to_string(pid) + "/maps");
        maps_file.openFileStream();

        std::string process_memory_line;

        while(std::getline(maps_file.getStreamFile(), process_memory_line))
        {
            if(process_memory_line.find(HEAP) != -1 || process_memory_line.find(STACK) != -1)
            {
                auto memory_block = StringManipulations::separateMemoryBlockFromMaps(process_memory_line);

                process_addresses.emplace_back(std::move(memory_block));
            }
        }

        return process_addresses;
    }

    const pid_t getProcessId() const
    {
        return _pid;
    }

    static pid_t getParentProcess(pid_t pid)
    {
        FileManager process_stat("/proc/" + std::to_string(pid) + "/stat");
        process_stat.openFileStream();

        std::string stat_line;
        std::getline(process_stat.getStreamFile(), stat_line);

        return StringManipulations::SeperatedParentIdFromStat(stat_line);
    }
};

#endif //TESTPROJECT_PROCESS_HPP

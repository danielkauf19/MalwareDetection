#ifndef TESTPROJECT_PROCESS_HPP
#define TESTPROJECT_PROCESS_HPP

#include <csignal>
#include <vector>
#include <iostream>
#include <optional>
#include <fstream>

#include "../Filesystem/FileManager.hpp"
#include "./MemoryBlock.hpp"

class Process
{
    static constexpr auto HEAP = "[heap]";
    static constexpr auto STACK = "[stack]";
    static constexpr auto STAT = "/stat";
    static constexpr auto MAPS = "/maps";
    static constexpr auto MEM = "/mem";

    pid_t _pid;
    std::vector<MemoryBlock> _process_addrs;

public:
    static constexpr auto PROC_PATH = "/proc/";

    Process(pid_t pid, std::vector<MemoryBlock>& process_addrs) :
        _pid(pid), _process_addrs(std::move(process_addrs))
    {
    }

    std::vector<char> readProcessMemBlock(uint64_t offset, uint64_t size) const
    {
        try
        {
            FileManager mem_file;
            std::vector<char> buffer(size);

            std::string mem_file_name = PROC_PATH + std::to_string(_pid) + MEM;

            mem_file.openFile(mem_file_name.c_str(), O_RDONLY);
            mem_file.seek(offset);
            mem_file.readProcessMemIntoBuffer(buffer, size, offset);

            return buffer;
        }
        catch(std::exception& e)
        {
            throw std::runtime_error("Error in Read Process " + std::to_string(_pid) + " Mem: " + e.what());
        }
    }

    void terminateProcess() const
    {
        int terminate = kill(_pid, SIGTERM);

        std::cout << "Process Id: " << _pid << " Terminated Successfully" << std::endl;

        if(terminate != 0)
        {
            throw std::runtime_error("Failed Terminate Process");
        }
    }

    const std::vector<MemoryBlock>& getMemoryBlocks() const
    {
        return _process_addrs;
    }

    static std::vector<MemoryBlock> getProcessMemoryAddresses(pid_t pid)
    {
        std::vector<MemoryBlock> process_addresses;
        std::ifstream maps_file(PROC_PATH + std::to_string(pid) + MAPS);

        std::string process_memory_line;

        while(std::getline(maps_file, process_memory_line))
        {
            if(process_memory_line.find(HEAP) != std::string::npos || process_memory_line.find(STACK) != std::string::npos)
            {
                auto memory_block = StringManipulations::separateMemoryBlockFromMaps(process_memory_line);

                process_addresses.emplace_back(std::move(memory_block));
            }
        }

        return process_addresses;
    }

    const pid_t getProcessId() const
    {
        return _pid;
    }

    static pid_t getParentProcess(pid_t pid)
    {
            std::ifstream stat_file(PROC_PATH + std::to_string(pid) + STAT);

            std::string stat_line;
            std::getline(stat_file, stat_line);

            return StringManipulations::SeperatedParentIdFromStat(stat_line);

    }
};

#endif //TESTPROJECT_PROCESS_HPP

#ifndef TESTPROJECT_PROCESSMANAGER_HPP
#define TESTPROJECT_PROCESSMANAGER_HPP

#include <unordered_map>

#include "./Process.hpp"
#include "../Utils/PatternsMatching.hpp"
#include "../Filesystem/FileManager.hpp"

class ProcessManager
{
    static constexpr auto MALICIOUS_ENGLISH = "I am a bad bad malware";
    static constexpr auto MALICIOUS_HEBREW = "אני תוכנית זדונית";

    std::unordered_map<pid_t, Process> _processes_cache;
    std::vector<pid_t> _parent_processes;
    std::vector<pid_t> _processes_garbage;

public:
    ProcessManager()
    {
        getAllParentProcesses();
        cacheAllProcesses();
    }

    // We don't want to run diagnostics on our parents processes
    // As thier termination would terminate us.
    // should be also critical processes, but as it varies on to many factors,
    // what is a critical process, and assuming system process and such won't contain malware
    // data, I have decided to consider critical Processes as only my parents hierarchy
    void getAllParentProcesses()
    {
        pid_t parent_process = getppid();
        _parent_processes.emplace_back(parent_process);

        parent_process = Process::getParentProcess(parent_process);

        while(parent_process != 1 && Process::getParentProcess(parent_process) != parent_process)
        {
            _parent_processes.emplace_back(parent_process);

            parent_process = Process::getParentProcess(parent_process);
        }
    }

    void cacheAllProcesses()
    {
        std::vector<pid_t> process_ids = fetchActiveProcessesIds();

        for (auto& pid : process_ids)
        {
            try
            {
                if(_processes_cache.find(pid) == _processes_cache.end())
                {
                    if(!isProcessRelated(pid) && pid != getpid())
                    {
                        auto process_mem = Process::getProcessMemoryAddresses(pid);
                        if(!process_mem.empty())
                        {
                            Process process(pid, process_mem);
                            _processes_cache.emplace(pid, std::move(process));
                        }
                    }
                }
            }
            catch(std::exception& e)
            {
                std::cerr << "Fail Mapping Process " << e.what() << std::endl;
            }
        }
    }

    void runMalwareDetection()
    {
        for (auto &[pid, process]: _processes_cache)
        {
            readProcMemAndHandle(process);
        }

        cleanGarbageProcesses();
        updateCache();
    }

    void readProcMemAndHandle(const Process& process)
    {
        pid_t potential_error_process_id = process.getProcessId();

        try
        {
            bool malicious_proc = false;
            auto proc_addrs = process.getMemoryBlocks();

            for (auto &addr: proc_addrs)
            {
                std::vector<char> buffer;
                auto size = addr.end_addr - addr.start_addr;
                buffer = process.readProcessMemBlock(addr.start_addr, size);

                if (PatternsMatching::maliciousPattern(buffer, MALICIOUS_ENGLISH) ||
                PatternsMatching::maliciousPattern(buffer, MALICIOUS_HEBREW))
                {
                    malicious_proc = true;
                    break;
                }
            }

            if (malicious_proc) {
                process.terminateProcess();

                _processes_garbage.emplace_back(potential_error_process_id);
            }
        }
        catch(std::exception& e)
        {
            std::cerr << "Error in diagnostic of process: " << e.what() << std::endl;
            _processes_garbage.emplace_back(potential_error_process_id);
        }
    }

    void updateCache()
    {
        cacheAllProcesses();
    }

    void cleanGarbageProcesses()
    {
        for(auto& garbage_proc : _processes_garbage)
        {
            _processes_cache.erase(garbage_proc);
        }

        _processes_garbage.clear();
    }

    bool isProcessRelated(pid_t pid)
    {
        for(auto& parent_id : _parent_processes)
        {
            if(pid == parent_id)
            {
                return true;
            }
        }

        return false;
    }

    static std::vector<pid_t> fetchActiveProcessesIds()
    {
        try
        {
            return FileManager::listDirEntrysDigits(Process::PROC_PATH); // which in PROC_PATH are process ids
        }
        catch(std::exception& e)
        {
            throw std::runtime_error(std::string("Error in Fetching Active processes: ") + e.what());
        }
    }
};

#endif //TESTPROJECT_PROCESSMANAGER_HPP
